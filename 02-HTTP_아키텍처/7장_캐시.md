## 07. 캐시

- 캐시는 웹 요청이 왔을때 캐시된 로컬 사본이 존재한다면 이 캐시로부터 응답을 제공한다.

### 7.1 불필요한 데이터 전송

- 클라이언트가 자주 서버에 접근을 할 때, 서버는 같은 문서를 클라이언트에게 전송하게 되는데 똑같은 바이트들이 네트워크를 통해 반복되어 이동한다. 이처럼 같은 데이터를 보내는 불필요한 데이터 전송은 네트워크 대역폭을 낭비하고, 전송을 느리게 하며, 웹 서버에 부하를 준다.

### 7.2 대역폭 병목

- 캐시는 네트워크 병목을 줄여준다.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같은데 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면 캐싱은 성능을 대폭 개선할 수 있을 것이다.

### 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
- 많은 사람이 거의 동시에 웹 문서에 접근할 때 발생하는 불필요한 트래픽 급증, 네트워크와 웹 서버의 심각한 장애를 해소시켜준다.

### 7.4 거리로 인한 지연

- 대역폭이 문제가 되지 않더라도, 물리적 거리가 문제가 될 수 있다.

### 7.5 적중과 부적중

- `캐시 적중(cache hit)` : 캐시에 요청이 도착했을때 그에 대응하는 사본이 있다면 이것을 이용해 요청을 처리한다.
- `캐시 부적중(cache miss)` : 위와 같은 상황에서 대응하는 사본이 없다면 그냥 서버로 전달한다.

### 7.5.1 재검사(Revalidation)

- 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야한다. 이러한 '신선도 검사'를 `HTTP 재검사`라고 부른다.
- 캐시는 클라이언트가 사본을 요청했을때 그 사본을 검사할 필요가 있을 정도로 오래되었을 경우 재검사를 진행한다.
- HTTP는 캐시된 객체를 재확인 하는 몇 가지 도구를 제공하는데 그 중 `If-Modified-Since 헤더`가 제일 많이 쓰인다.
- If-Modified-Since 헤더는 GET요청을 보냈을때만 사본을 보내달라는 의미이다.
- 재검사 적중 : 서버의 객체가 변경되지 않았다면 `HTTP 304 Not Modified` 응답을 보낸다.
- 재검사 부적중 : 캐시된 사본과 다르다면 `HTTP 200 OK` 응답을 보낸다.
- 객체 삭제 : 서버 객체가 삭제되었다면 `404 Not Found` 응답을 보내고 캐시는 사본을 삭제한다.

### 7.5.2 적중률

- 캐시가 요청을 처리하는 비율을 `캐시 적중률`이라고 부른다.

### 7.5.3 바이트 적중률

- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.

### 7.5.4 적중과 부적중의 구별

- 클라이언트에게 응답이 캐시에서 왔는지 알아내는 방법 또는 감지하는 방법은 `Date 헤더`를 이용하는 방법과 `Age 헤더`를 이용하는 방법이 있다.

### 7.6 캐시 토폴로지(topology: 망형 네트워크 형태)

- 캐시는 한 명의 사용자에게 할당될 수도 있고 여러 명의 사용자들 간에 공유될 수 있다.
- 한 명에게만 할당된 캐시를 `개인 전용 캐시`, 공유된 캐시를 `공용 캐시`라고 한다.

### 7.6.1 개인 전용 캐시

- 개인 정용 캐시는 많은 에너지나 저장공간이 필요하지 않으며 대부분의 브라우저는 자주쓰는 문서에 개인 전용 캐시를 내장하고 있어서 사용하게 된다.

### 7.6.2 공용 프록시 캐시

- 공용 캐시는 프록시 캐시라 불리는 특별한 종류의 공유된 프록시 서버이다.

### 7.6.3 프록시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식.
- 캐시 계층이 깊어지고 프록시 연쇄가 길어질수록 각 중간 프록시는 현저한 성능저하가 발생할 것이다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 단순한 캐시 계층 대신 복잡한 캐시망을 만드는데 캐시 사이의 관계는, 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다.

### 7.7 캐시 처리 단계

- 오늘날 상용 프록시 캐시는 꽤 복잡하다.
- 웹 캐시의 기본적인 동작은 대개 단순하며, HTTP 메소드로 메세지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져 있다.

### 7.7.1 단계 1: 요청받기

- 캐시는 들어오는 데이터를 읽어들이고 메세지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.

### 7.7.2 단계 2: 파싱

- 캐시는 요청 메세지를 여러부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.

### 7.7.3 단계 3: 검색

- 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.

### 7.7.4 단계 4: 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해주는데 이 기간 동안 문서가 신선하다면 서버와 접촉 없이 캐시가 보유하고 있는 사본을 제공하는 것으로 신선하지 않으면 해당 문서에 변경이 있어 있었는지 재검사를 해야한다.

### 7.7.5 단계 5: 응답 생성

- 캐시는 캐시와 서버 응답 헤더를 토대로 응답 헤더를 생성하며 이 해더들은 캐시에 의해 수정되고 늘어난다.

### 7.7.6 단계 6: 전송

- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다.

### 7.7.7 단계 7: 로깅

- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지하며 캐시 트랜잭션 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.

### 7.8 사본을 신선하게 유지하기

- 캐시된 사본 모두가 서버의 문서와 항상 일지하는 것이 아니다.
- 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

### 7.8.1 문서 만료

- HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일수 있게 해준다.

### 7.8.2 유효기간과 나이

- Cache-Control: max-age : 문서의 최대 나이를 정의한다.
- Expires : 절대 유효기간을 명시한다.

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은 검사할 시간이 되었음을 뜻한다.
- 이 검사를 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미하는 서버 재검사라고 한다.
- 캐시는 문서의 신선도를 매 요청마다 검증할 필요는 업고 문서가 만료되었을때 한번만 서버와 재검사하면 된다.

### 7.8.4 조건부 메서드와의 재검사

- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.

### 7.8.5 If-Modified-Since(IMS): 날짜 재검사

- 문서가 주어진 날짜 이후에 변경되었으면 200 상태코드와 새문서, 새로운 만료날짜와 그외의 정보를 준다.
- 문서가 변경되지 않았으면 304 Not Modified 응답 메세지를 클라이언트에게 보내준다.

### 7.8.6 If-None-Match: 엔티티 태그 재검사

- 문서가 변경되었을때 문서의 엔티티 태그를 새로운 버전에 표현할 수 있다.

### 7.8.7 약한 검사기와 강한 검사기

- 강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다.
- 약한 검사기는 어느정도 콘텐츠 변경은 허용하지만 중요한 부분이 변경되면 다같이 변경된다.
- 강한 엔티티 태그는 대응하는 엔티티 값이 어떻게 바뀌든 매번 같이 바뀌어야한다.
- 약한 엔티티 태그는 대응하는 엔티티에 유의미한 변경이 있을 때마다 같이 변경되어야한다.

### 7.8.8 언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP.1.1 클라이언트는 만약 서버가 엔티티 태그를 반환했다면, 반드시 엔티티 태그 검사기를 사용해야 한다.

### 7.9 캐시 제어

- HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의한다.
  - `no-store`, `no-cache`, `must-revalidate`, `max-age`, `Expires` 헤더들은 응답에 첨부할 수 있다.

### 7.9.1 no-cache와 no-store 응답 헤더

- no-store와 no-cache 헤더는 캐시가 검증 되지 않은 캐시된 객체로 응답하는 것을 막는다.
- `'no-store'`가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다.
  - 캐시는 보통 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다.
- `'no-cache'`로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다.
  - 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

### 7.9.2 Max-Age 응답 헤더

- max-age 헤더는 문서가 서버로부터 온 이후로 흐른 시간이고, 초단위로 나타낸다.

### 7.9.3 Expires 응답 헤더

- 캐시의 실제 만료 날자이다.

### 7.9.4 Must-Revalidate 응답 헤더

- must-revalidate 응답 헤더는 신선하지 않는 사본을 원 서버와 최초의 재검사 없이는 제공해서는 안 됨을 의미한다.

### 7.9.5 휴리스틱 만료

- max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면 캐시는 경험적인 방법으로(heuristic) 최대 나이를 계산할 것이다.
- 일반적으로 사람들은 휴리스틱 신선도 유지기간에 상한을 설정하여 지나치게 커지는 것을 막는다.(보통 1주일로 하지만, 보수적인 사이트는 하루로 설정한다.)

### 7.10 캐시 제어 설정

- 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공한다.  
  후의 다른 설명은 아파치 서버의 기준에 의한 설명이므로 생략하겠다.
