## 03.HTTP 메시지
  - HTTP가 인터넷의 배달원이라면, HTTP메시지는 무언가를 담아 보내는 소포같다.  
### 3.1 메시지의 흐름
  - HTTP메시지는 HTTP 애플리케이션 간에 주고 받은 데이터 블록들이다.
### 3.1.1 메세지는 원서버 방향을 인바운드로 하여 송신된다.
  - 이번 절은 내용이 다 중요해서 그대로 옮긴다....
  - HTTP에서 트랜잭션의 방향을 설명하기 위해 인바운드와 아웃바운드를 사용한다.
  - 메시지가 원 서버로 향하는 것을 인바운드(`클라이언트 -> 서버`)
  - 모든 처리가 끝난 뒤 메시지가 사용자에게 돌아오는것이 아웃바운드(`서버 -> 클라이언트`)
### 3.1.2 다운스트림으로 흐르는 메시지
  - 요청 메시지냐, 응답 메시지냐에 관계 없이 모든 메시지는 다운스트림으로 흐른다.
  - 클라이언트 -> 프록시1 -> 프록시2 -> 서버 -> 프록시2 -> 프록시1 -> 클라이언트 이 흐름을 생각하면 다운스트림이라는 말이 이해가 될 것이다.
### 3.2 메시지의 각 부분
  - 메시지는 `시작줄`, `헤더블록`, `본문`으로 이루어져있다.
  - 시작줄은 어떤 메시지인지 서술하며, 헤더블록은 속성(ex: Context-Type, Context-length 각각 본문이 뭔지, 길이가 어떤지를 나타낸다.)을 본문은 단순히 데이터를 담고 있다.
  - 엔티티 본문이나 메시지 본문(혹은 그냥 '본문')은 단순히 선택적인 데이터 덩어리이다.
  - 예를 들어 Content-Type줄은 본문이 무엇인지 설명해준다. Content-Length줄은 본문의 크기 혹은 길이를 말해준다.
### 3.2.1 메시지 문법
  - `요청 메시지`: 웹 서버에 어떤 동작을 요구한다.
  - `응답 메시지`: 요청의 결과를 클라이언트에게 돌려준다.
  - 요청 메시지의 형식
    ```html
    <메서드> <요청 URL> <버전>
    <헤더>
      (공백)
    <엔티티 본문>
    ```
  - 응답 메시지의 형식
    ```html
    <버전> <상태 코드> <사유 구절>
    <헤더>
      (공백)
    <엔티티 본문>
    ```
  - 메서드
    - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
    - ex: `GET`,`HEAD`,`POST` 등등
  - 요청 URL
    - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소이다.
  - 버전
    - 사용중인 HTTP의 버전이다. 
    - 형식은  `HTTP/<메이저>.<마이너>`로 이루어져있고 메이저와 마이너는 모두 정수이다.
  - 상태코드
    - 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자다. 각 코드의 첫번째 자릿수로 상태의 일반적인 분류를 나타낸다.
  - 사유 구정
    - 상태 코드의 의미를 짧은 문구로 문자열로 나타낸 구절이다.
  - 헤더들
    - 이름, 콜론(:), 공백, CRLF가 순서대로 나타다는 헤더들이 며 헤더의 끝은 빈줄(CRLF)로 끝이 난다.
  - 엔티티 본문
    - 본문이 가지고 있는 임의의 데이터 블록을 포함한다.
    - 헤더나 엔티티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝난다.
### 3.2.2 시작줄
  - 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야할지 알려주며 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.
  - 요청줄
    - 요청줄에서는 메소드(어떤동작이 일어나야하는지), 요청 URL(동작 대상), HTTP 버전( 어떤 HTTP 버전을 쓰는지)를 포함하고 있다.
    - 위 모든 필드는 공백으로 구분된다.
  - 응답줄
    - 응답 메시지는 수행결과에 대한 상태정보와 결과 데이터를 클라이언트에게 준다.
    - 응답 메시지의 시작줄은 HTTP 버전, 숫자로 된 상태코드, 사유 구절이 들어 있다.
  - 메서드
    - 요청의 시작줄은 메서드로 시작하며, HTTP 명세는 공통 요청 메서드의 집합을 정의한다.
      |메서드|설명|메시지 본문이 있는가?|
      |-----|---|-------------------|
      |GET|서버에서 어떤 문서를 가져온다.|없음|
      |HEAD|서버에서 어떤 문서에 대해 헤더만 가져온다.|없음|
      |POST|서버가 처리해야 할 데이터를 보낸다.|있음|
      |PUT|서버에 요청 메시지의 본문을 저장한다.|있음|
      |TRACE|메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다.|없음|
      |OPTIONS|서버가 어떤 메서드를 수행할 수 있느닞 확인한다.|없음|
      |DELETE|서버에서 문서를 제거한다.|없음|
  - 상태코드
    - 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다.
      |전체 범위|정의된 범위|분류|
      |-------|----------|----|
      |100-199|100-101|정보|
      |200-299|200-206|성공|
      |300-399|300-305|리다이렉션|
      |400-499|400-415|클라이언트 에러|
      |500-599|500-505|서버 에러|
  - 사유 구절
    - 사유 구절은 시작줄의 마지막 요소이다.
    - 상태코드에 대한 글로 된 설명을 제공한다.
  - 버전 번호
    - 요청과 응답 메시지 양쪽 모두 시술되어 있다.
    - HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.
### 3.2.3 헤더
  - HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다.
  - 헤더 분류
    - 일반 헤더: 요청과 응답 양쪽에서 모두 나타날 수 있다.
    - 요청 헤더: 요청에 대한 부가 정보를 제공
    - 응답 헤더: 응답에 대한 부가 정보를 제공
    - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
    - 확장 헤더: 명세에 정의되지 않은 새로운 헤더
  - 헤더를 여러 줄로 나누기위해서는 줄내림후 최소 하나의 스페이스 혹은 탭 문자가 와야된다.
### 3.2.4 엔티티 본문
  - HTTP 메세지의 본문에 해당하는 부분
### 3.2.5 버전 0.9 메세지
  - HTTP 0.9 메세지도 요청과 응답으로 이루어져 있지만 요청은 그저 에서드와 요청URL을 갖고, 응답은 오직 엔티티로만으로 이루어져 있다.
  - 게다가 너무 단순해서 다양한 상황에 대응이 불가능하다.
### 3.3 메서드
  - 모든 서버가 모든 메서드를 구현하지 않는다.
  - 또한 사용되는 메서드는 사이트 또는 서버에 마다 다르다.
### 3.3.1 안전한 메서드(Safe Method)
  - GET이나 HEAD메서드를 사용하는 HTTP요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
### 3.3.2 GET
  - 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
### 3.3.3 HEAD
  - HEAD 메서드는 GET처럼 행동하지만 서버는 응답으로 헤더만을 돌려준다.
  - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이나 길이 등등)을 알아낼 수 있다.
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
  - 헤더를 확인하여 리소스가 변경되었느지 검사할 수 있다.
### 3.3.4 PUT
  - PUT 메서드는 서버에 문서를 쓴다.
  - PUT메서드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.
### 3.3.5 POST
  - POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다.
  - 예로 HTML의 form태그에 담긴 데이터를 서버에 전송한다.
### 3.3.6 TRACE
  - TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을때 어떻게 보이게 되는지 알려준다.
  - 자세하게는 클라이언트에서 요청을 보내면 요청이 방화벽, 프록시, 게이트웨이 등의 어플리케이션을 통과하는데 이 과정을 거쳐 도달했을때의 결과를 보여준다.
  - 주로 요청이 어떤 영향을 미치는지 확인할때 사용된다.
### 3.3.7 OPTIONS
  - OPTIONS 메서드는 웹 서버에게 여러가지 종류의 지원 범위에 대해 물어본다.
### 3.3.8 DELETE
  - DELETE 메서드는 서버에게 요청URL로 지정한 리소스를 삭제할 것을 요청한다.
  - 단, HTTP명세는 서버가 클라이런트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문에 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.
### 3.3.9 확장 메서드
  - 확장메서드는 HTTP/1.1명세에 정의되지 않은 메서드이다.
  - HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로운 기능을 추가해도 되기 떄문에 새로 메서드를 정의 해서 사용할 수 있다.
### 3.4 상태 코드
  - 상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법(상태코드, 사유구절)을 제공한다.
### 3.4.1 100-199: 정보성 상태 코드
  - 정보성 상태 코드는 HTTP/1.1에서 도입되었다.
  - `100 Continue`
    - 요청의 시작부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다.
  - `101 Swiching Protocols`
    - 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바뀌었음을 의미한다.
  - 클라이언트와 100 Continue
    - 클라이언트가 엔티티를 서버에 보내려고 할 때만 100-continue로 하는 Expect 요청 헤더를 한다.
    - (`Expect 헤더`: 서버에게 서버가 어떻게 동작하길 바라는지 알려주기위해 클라이언트가 사용한다.)
  - 서버와 100 Continue
    - 서버가 100-continue값이 담긴 Expect 헤더가 포함된 요청을 받는다면 100-Continue 응답 혹은 에러코드로 답해야 한다.
  - 프록시와 100 Continue
    - 클라이언트로부터 100-continue응답을 의도한 요청을 받은 프록시는 다음 홉(next-hop) 서버들에 대한 상태 몇가지와 지원하는 HTTP버전을 기억해두고 100-continue 응답을 한다.
### 3.4.2 200-299: 성공 상태 코드
  - 클라이언트가 요청을 보내면 대게 성공하고 서버는 대응하는 성공을 의미하는 상태 코드를 보낸다.
  - `200(OK)` 요청은 정상이고, 엔티티 본문은 요청된 리소스를 포함하고 있다.
  - 이 외에 201(Create), 202(Accepted), 203(Non-Authoritative Information), 204(No Content), 205(Reset Content), 206(Partial Content) 등이 있다.
### 3.4.3 300-399: 리다이렉션 상태 코드
  - 리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
  - 리다이렉션 상태 코드중 몇몇은 리소스에 대한 어플리케이션의 로컬 복사본이 원래 서버와 비교했을때 유효한지 확인하기 위해 사용된다.
  - 변한 것이 없다면, 서버는 콘텐츠 대신 304 상태 코드로 답할 것이다.
  - `304(Not Modified)` 클라이언트가 요청을 보낸뒤 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드는 엔티티 본문을 가지지 못한다.
  - 그 외에 300(Multiple Choices), 301(Moved Permanently), 302(Found), 303(See Other), 305(Use Proxy), 306(사용되지 않음), 307(Temporary Redirect)
  - 이 상태 코드들은 HTTP/1.0과 HTTP/1.1의 상태코드 다루는 방식에 따라 다르다.
  - 즉 적절한 리다이렉트 상태 코드를 선택하기 위해서는 클라이언크의 HTTP 버전을 검사 할 필요가 있다. 
### 3.4.4 400-499: 클라리언트 에러 상태 코드
  - 클라이언트가 서버는 다룰 수 없는 무언가를 보냈을때 나 올 수 있는 상태 코드이다.
  - 가장 흔한 것으로는 존재하지 않는 URL에 대한 요청 `404(Not Found)` 에러이다.
  - 그 외에 400(Bad Request), 401(Unauthorized), 402(Payment Required), 403(Fobidden), 404(Not Found), 405(Method Not Allowed), 406(Not Acceptable), 407(Proxy Authentication Required), 408(Request Timeout), 409(Conflict), 410(Gone), 411(Length Required), 412(Precondition Failed), 413(Request Entity Too Large), 414(Request URI Too Long), 415(Unsupported Media Type), 416(Requested Range Not Stisfiable), 417(Expectation Failed) 가 있다.
### 3.4.5 500-599: 서버 에러 상태 코드
  - 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다.
  - 주로 `500(Internal Server Error)` 서버가 요청을 처리할 수 없게 만드는 에러를 만났을때 사용한다.
  - 그 외에 501(Not Implemented), 502(Bad Gateway), 503(Service Unavailable), 504(Gateway Timeout), 505(HTTP Version Not Supported) 가 있다. 서버 에러 코드는 많이 본 적이 있다.
### 3.5 헤더
  - 헤더와 메소드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함계 사용된다.
  - 일반 헤더(General Headers)
    - 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다.
    - ex) Date헤더는 요청, 응답을 가리지 않고 나온다. `Date: Tue, 3 Oct 1974 02:16:00 GMT`
  - 요청 헤더(Request Headers)
    - 요청 헤더는 요청 메세지를 위한 헤더다
    - ex) Accept 헤더의 경우 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아줄것을 뜻한다. `Accept: */*`
  - 응답 헤더(Response Headers)
    - 응답 메세지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.
    - ex) 응답은 서버가 주는 것으로 Server 헤더. `Server: Tiki-Hut/1.0`
  - 엔티티 헤더(Entity Headers)
    - 엔티티 본문에 대한 헤더를 말한다. 
    - ex) `Content-Type: text/html; charset=iso-latin-1`
  - 확장 헤더(Extension Headers)
    - 아직 승인된 HTTP명세에는 추가되지 않은 비표준 헤더다.
### 3.5.1 일반 헤더
  - 헤더는 메세지에 대한 아주 기본적인 정보를 제공한다. 이런 헤더들을 일반 헤더라고 불린다.
  - `일반 캐시 헤더`
    - HTTP/1.0에서는 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.
### 3.5.2 요청 헤더
  - 요청 헤더는 요청 메세지에만 의미를 갖는 헤더다.
  - Accept 관련 헤더
    - 클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있다.
    - 즉, Accept관련 헤더들은 서버와 클라이언트 양쪽 모두에게 유익하다.
  - 조건부 요청 헤더
    - 클라이언트는 요청에 몇몇 제약을 넣기도 한다. 예를 들어 자신이 갖고 있는 사본과 다를 때만 전송해 달라고 요청할도 수 있다.
  - 요청 보안 헤더
    - HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.
    - 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 말들고자 한다.
  - 프록시 요청 헤더
    - 요청시 거쳐가는 프록시의 기능을 돕기 위해 생성된 헤더
### 3.5.3 응답 헤더
  - 응답 메세지는 그들만의 응답 헤더를 갖는다. 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
  - 협상 헤더
    - 여러가지 표현이 가능한 상황이라면 HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있도록 돕는 헤더
  - 응답 보안 헤더
    - 기본적으로 HTTP 인증요구/응답 체계에서 응답 측에 해당하는 요청 보안 헤더이다.
### 3.5.4 엔티티 헤더
  - HTTP 메세지의 엔티티에 대해 설정하는 헤더들이다.
  - 헤더들은 양쪽의 타입의 메세지에 모두 나타날 수 있다.
