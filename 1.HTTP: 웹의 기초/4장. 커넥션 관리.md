## 04. 커넥션 관리  
  - HTTP는 어떻게 TCP 커넥션을 사용하는가
  - TCP 커넥션의 지연, 병목, 막힘
  - 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
  - 커넥션 관리를 위해 따라야 할 규칙들
### 4.1 TCP 커넥션
  - 전 세계 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.
  - 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.
  - 커넥션의 과정
    1. URL을 통해 IP주소, 포트 번호를 얻는다.
    2. 브라우저가 IP주소, 포트 번호를 이용해 TCP 커넥션을 생성한다.
    3. 브라우저가 서버로 HTTP 요청 메세지를 보낸다.
    4. 브라우저가 서버에서 온 HTTP 응답 메세지를 읽는다.
    5. 브라우저가 커넥션을 끊는다.
### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP
  - TCP 커넥션은 인터넷을 안정적으로 연결해준다.
  - TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확하게 전달된다.
### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
  - TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송한다.
  - TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP패킷에 담아 인터넷을 통해 데이터를 전달한다.
  - IP 패킷에는 다음과 같은 내용이 들어있다.
    - IP 패킷 헤더 : 발신지와 목적지 IP주소, 크기, 기타 플래그 등등을 가진다.
    - TCP 세그먼트 헤더 : TCP 포트번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값
    - TCP 데이터 조각
### 4.1.3 TCP 커넥션 유지하기
  - TCP는 포트 번호를 통해서 여러 개의 커넥션을 유지한다.
  - TCP 커넥션은 네가지 값으로 식별한다.
    - `<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`
### 4.1.4 TCP
  - 소켓 API를 사용하면, TCP endpoint 데이터 구조를 생성하고, 원격 서버의 TCP endpoint에 그 endpoint 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
  - TCP API는 기본적인 네트워크 프로토콜의 핸드 셰이킹, 그리고 TCP 데이터 스트림과 IP패킷간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.
### 4.2 TCP의 성능에 대한 고려
  - HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.
### 4.3 HTTP 커넥션 관리
### 4.3.1 흔히 잘못 이해하는 Connection 헤더
  - HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다.
  - Connection 헤더에는 다음 세 가지 종류의 토큰이 전달될 수 있기 때문에 혼란스러울 수 있다.
  - 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면 해당 필드들은 현재 커넥션 만을 위한 정보이므로 다음 커넥션에는 전달해선 안 된다.
  - Connection 헤더에 있는 모든 헤더 필드는 메세지를 다른 곳으로 보내는 시점에서 삭제되어야 한다.
  - Connection 헤더는 전송자가 특정 커넥션에만 해당되는 옵션을 지정하게 해준다.
### 4.3.2 순차적인 트랜잭션 처리에 의한 지연
  - 순차적인 처리로 인한 지연에는 물리적인 지연뿐만 아니라 심리적인 지연도 있다.
  - HTTP 커넥션의 성능을 향상시킬 수 있는 여러 최신기술이 있다.
  - `병렬(parallel) 커넥션`: 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
  - `지속(persistent)커넥션`: 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
  - `파이프라인(pipelined)커넥션`: 공유 TCP 커넥션을 통한 병렬 HTTP 요청
  - `다중(multiplexed)커넥션`: 요청과 응답들에 대한 중재(실험적?인 기술이라고 한다.)
### 4.4 병렬 커넥션
  - HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 트랜잭션을 병렬로 처리할 수 있게 한다.
### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.
  - 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는것이 아니라면 나머지 객체를 내려받는데 남은 대역폭을 사용할 수 있다.
### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.
  - 클라이언트의 네트워크 대역폭이 좁을 때, 여러개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어진다.
  - 또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.
### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다.
  - 병렬 커넥션이 페이지를 항상 더 빠르게 로드하지는 않지만 화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있으면 그것을 더 빠르다고 여긴다.
### 4.5 지속 커넥션
  - 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 한다.
  - HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.
### 4.5.1 지속 커넥션 vs 병렬 커넥션
  - 병렬 커넥션의 단점
    - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
    - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
    - 실제로 연결할 수 있는 병렬 커넥션의 수에 제한이 있다.
  - 지속 커넥션의 병렬 커넥션보다 나은 장점
    - 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고
    - 튜닝된 커넥션(다수의 패킷을 전송할 수 있는 권한을 지닌 커넥션)을 유지하며
    - 커넥션의 수를 줄임
  - HTTP/1.0+에는 `keep-alive` 커넥션이 있고 HTTP/1.1에는 `지속`커넥션이 있다.
### 4.5.2 HTTP/1.0+의 Kepp-Alive 커넥션
  - keep-alive 커넥션의 성능상의 장점은 연속적으로 커넥션을 생성하여 커넥션의 맺고 끊는데 필요한 작업이 업게되어 시간이 단축된다.
### 4.5.3 Keep-Alive 동작
  - keep-alive는 HTTP/1.1명세에서 빠져있지만 아직 사용되고 있기때문에 처리할 수 있도록 해줘야 한다.
  - HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 Connection:Keep-Alive 헤더를 포함하고 이 요청을 받은 서버는 응답 메세지에 같은 헤더를 포함시켜 응답한다.
### 4.5.4 Keep-Alive 옵션
  - timeout 파라메터 : 커넥션이 얼마간 유지될 것인지를 의미한다.
  - max 파라메터 : 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때 까지 유지될 것인지를 의미한다.
  - Keep-Alive 헤더: 진단이나 디버깅을 주목적으로 하는 처리되지 않는 임의의 속성들을 지원하기도 한다.
  - ex : `Keep-Alive: max=5, timeout=120`
### 4.5.5 Keep-Alive 커넥션 제한과 규칙
### 4.5.6 Keep-Alive와 멍청한(dumb) 프록시
  - 멍청한 프록시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로 다음 프록시에 전달한다.
  - 왜 멍청한지는 이렇게 헤더를 이해하지 못하고 요청을 보내고 응답 메세지의 헤더에 Connection헤더에 Keep-Alive를 가지고 있어서 커넥션이 끊어지지 않는다.
  - 여기서 같은 커넥션에 새로운 요청이 들어오게되면 이 요청은 프록시로부터 무시되고 브라우저에 응답으로 아무런 응답 없이 로드중이라는 표시가 나오게된다.
### 4.5.7 Proxy-Connection 살펴보기
  - 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection이라는 헤더를 사용한다.
  - 넷스케이프는 비표준인 Proxy-Connection 확장 헤더를 프록시에게 전달하고 프록시가 무조건 전달하더라도 서버는 그것을 무시하기 때문에 문제가 되지않는다.
  - 영리한 프록시는 의미 없는 Proxy-Connection 헤더를 Connection 헤더로 바꿈으로써 원하던 효과(keep-alive)를 얻을 수 있다.
  - 단, 이 방식은 클라이언트와 서버사이에 한 개의 프록시만 있는 경우에서만 동작하며 프록시가 앞뒤로 더 있다면 문제는 다시 발생할 수 있다.
  - 이것을 막기위해서는 보이지 않는 웹 애플리케이션들이 지속적인 커넥션을 명확히 구현하는 것이 중요하다.
### 4.5.8 HTTP/1.1의 지속 커넥션
  - HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 지속 커넥션이 기본적으로 활성이 되어있다.
  - HTTP/1.1는 별도의 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다.
  - HTTP/1.1에서 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection:close헤더를 명시해야 한다.
### 4.5.9 지속 커넥션의 제한과 규칙
  - 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.
